# 섹션6. 스프링 DB 접근 기술
- 순수 JDBC
- 스프링 통합 테스트
- 스프링 JDBC template
- JPA

## 순수 JDBC
어플리케이션과 데이터를 연결하는데, DB에 insert/select query를 날려서 데이터를 저장하는 방법 

순수 JDBC: 20년 전 방법 (참고만 하면 된다.)

1. JdbcMemberRepository 생성
<소스 코드>
2. SpringConfig 변경
<소스 코드>

cf) 개방 폐쇄 원칙(OCP): 확장에는 열려 있고, 수정/변경에는 닫혀 있다.

-> 기능을 완전히 변경해도, 애플리케이션이 동작하는 데 필요한 코드를 수정할 필요 X (조립하는 코드만 수정하면 됨)

-> 스프링의 Dependency Injection에 의해 OCP가 만족됨

## 스프링 통합 테스트
스프링 컨테이너와 DB를 연결한 통합 테스트

(지금까지의 test는 순수 Java에 대한 test, 지금의 코드는 Spring이 DB를 붙들고 있기 때문에 앞선 방식으로 test를 진행할 수 없고, 다른 방식으로 test를 진행해야 함)

1. 기존의 MemberServiceTest.java를 복제하여 MemberServiceIngergationTest.java 파일을 만든다.

test-java-hello.hellospring-service-MemberServiceIngrationTest.java


```java

      package hello.hellospring.service;
      
      import hello.hellospring.domain.Member;
      import hello.hellospring.repository.MemoryMemberRepository;
      import org.assertj.core.api.Assertions;
      import org.junit.jupiter.api.AfterEach;
      import org.junit.jupiter.api.BeforeEach;
      import org.junit.jupiter.api.Test;
      
      import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
      import static org.junit.jupiter.api.Assertions.assertThrows;
      
      class MemberServiceIntegrationTest {
      
          MemberService memberService;
          MemoryMemberRepository memberRepository;
      
          @BeforeEach // 각 테스트를 사용하기 전에 같은 메모리 레포지토리를 사용하게 함
          public void beforeEach(){
              memberRepository = new MemoryMemberRepository();
              memberService = new MemberService(memberRepository);
          }
      
          @AfterEach // 동작이 끝날 때마다 수행한다는 의미
          public void afterEach(){
              memberRepository.clearStore();
          }
          @Test
          void 회원가입() { // test code는 한글로 적어도 됨
              // given
              Member member = new Member();
              member.setName(("hello"));
      
              // when
              Long saveId = memberService.join(member);
      
      
              // then
              Member findMember = memberService.findOne(saveId).get();
              Assertions.assertThat(member.getName()).isEqualTo(findMember.getName());
          }
      
          @Test
          public void 중복_회원_예외(){ // 이름이 중복되는 회원이 가입하려고 할 때 예외 처리가 정상적으로 수행되는지 확인
              // given
              Member member1 = new Member();
              member1.setName("spring");
      
              Member member2 = new Member();
              member2.setName("spring"); // member 이름이 중복됨
      
              // when
              memberService.join(member1);
              IllegalStateException e = assertThrows(IllegalStateException.class, () -> memberService.join(member2));// A -> B: B가 실행되면 A가 터져야 함
      
              assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다."); // 중복 회원이 발생했을 때 이 메시지가 정상적으로 발생하는지 확인
      
      
              // then
          }
          @Test
          void findMembers() {
          }
      
          @Test
          void findOne() {
          }
      }
```


2. MemberServiceIngergationTest.java 코드 수정
  cf) @SpringBootTest: 스프링 컨테이나와 테스트를 함께 실행함.
 
  cf) @Transactional: 이걸 test case에 달면, test를 실행할 때,
     transactional을 먼저 실행하고, DB에 데이터를 다 넣은 다음에, test가 끝나면 롤백을 해줌.
     즉, DB에 넣었던 데이터가 반영이 안 되고 지워짐. (다음 테스트에 영향 X)
```java
package hello.hellospring.service;
import hello.hellospring.domain.Member;
import hello.hellospring.repository.MemberRepository;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.transaction.annotation.Transactional;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;

@SpringBootTest
@Transactional
class MemberServiceIntegrationTest {
     @Autowired MemberService memberService;
     @Autowired MemberRepository memberRepository;
    
     @Test
     public void 회원가입() throws Exception {
    
        //Given
         Member member = new Member();
         member.setName("hello");
        
        //When
         Long saveId = memberService.join(member);
        
        //Then
         Member findMember = memberRepository.findById(saveId).get();
         assertEquals(member.getName(), findMember.getName());
     }
     @Test
    
     public void 중복_회원_예외() throws Exception {
    
         //Given
         Member member1 = new Member();
         member1.setName("spring");
         Member member2 = new Member();
         member2.setName("spring");
        
         //When
         memberService.join(member1);
         IllegalStateException e = assertThrows(IllegalStateException.class,
         () -> memberService.join(member2));//예외가 발생해야 한다.
         assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다.");
     }
}
```

## 스프링 JdbcTemplate
- Jdbc API에서 중복을 줄여줌.
- SQL은 직접 작성해야 함.

1. JdbcTemplateMemberRepository.java 생성
2. MemberRepository implements
3. JdbcTemplate jdbcTemplate ->  JdbcTemplateMemberRepository 함수에 DataSource dataSorce를 인젝션 받음
4. implement 받은 MemberRepository의 함수들을 jdbcTemplate을 사용해서 수정

main-java-hello.hellospring-repository-JdbcTemplateMemberRepository
```java
package hello.hellospring.repository;
import hello.hellospring.domain.Member;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import javax.sql.DataSource;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
public class JdbcTemplateMemberRepository implements MemberRepository {
   private final JdbcTemplate jdbcTemplate;
   public JdbcTemplateMemberRepository(DataSource dataSource) {
     jdbcTemplate = new JdbcTemplate(dataSource);
   }
   @Override
   public Member save(Member member) {
     SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate);
     jdbcInsert.withTableName("member").usingGeneratedKeyColumns("id");
     Map<String, Object> parameters = new HashMap<>();
     parameters.put("name", member.getName());
     Number key = jdbcInsert.executeAndReturnKey(new
    MapSqlParameterSource(parameters));
     member.setId(key.longValue());
     return member;
   }
   @Override
   public Optional<Member> findById(Long id) {
     List<Member> result = jdbcTemplate.query("select * from member where id 
    = ?", memberRowMapper(), id);
     return result.stream().findAny();
   }
   @Override
   public List<Member> findAll() {
     return jdbcTemplate.query("select * from member", memberRowMapper());
   }
   @Override
   public Optional<Member> findByName(String name) {
     List<Member> result = jdbcTemplate.query("select * from member where 
    name = ?", memberRowMapper(), name);
     return result.stream().findAny();
   }
   private RowMapper<Member> memberRowMapper() {
       return (rs, rowNum) -> {
       Member member = new Member();
       member.setId(rs.getLong("id"));
       member.setName(rs.getString("name"));
       return member;
       };
     }
}
```


6. SpringConfig의 MemberRepository 함수를 JdacTemplateMemperRepository(dataSource)로 바꿈
```java
public MemberRepository memberRepository() {
  // return new MemoryMemberRepository();
  // return new JdbcMemberRepository(dataSource);
   return new JdbcTemplateMemberRepository(dataSource);
 }
```
cf) 생성자가 하나만 있으면 @Autowired를 생략할 수 있음
cf) Jdbc에서 try-catch의 긴 코드로 이루어진 부분을 스프링의 Jdbc template에서는 jdbcTemplate 라이브러리로 간단하게 구현됨

## JPA
- Jdbc API에서 중복을 줄여줌
- 기본적인 SQL도 직접 만들어서 실행해줌
(객체를 메모리에 넣듯이 JPA에 넣으면, DB에 넣고/가져오는 동작을 JPA가 실행해줌)

1. build.grandle에 jpa 추가

hello-spring - build.grandle
```java
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    //implementation 'org.springframework.boot:spring-boot-starter-jdbc'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    runtimeOnly 'com.h2database:h2'
    testImplementation('org.springframework.boot:spring-boot-starter-test') {
        exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
    }
}
```

2. application.properties에 JPA 설정 추가
```java
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=none
```

cf) show-sql: JPA가 생성하는 SQL을 출력

cf) ddl-auto=none: 이미 테이블이 만들어져 있기 때문에 자동으로 테이블 생성 기능은 끔

3. Entity Mapping

cf) JPA는 인터페이스고, 구현은 여러 업체들이 함

cf) JPA: ORM 기술 (object와 relational data base table을 mapping함. 어떻게? 어노테이션으)

main - java - hello.hellospring - domain - Member
```java
package hello.hellospring.domain;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
@Entity
public class Member {
   @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
   private Long id;
   private String name;
   public Long getId() {
     return id;
   }
   public void setId(Long id) {
     this.id = id;
   }
   public String getName() {
     return name;
   }
   public void setName(String name) {
     this.name = name;
   }
}
```

4. 리포지토리 생성

main - java - hello.hellospring - repository
cf) JPA는 EntitiyManager로 모든 동작을 함 -> MemberRepository를 implements 받아 EntitiyManager를 사용하는 방식으로 override

```java
package hello.hellospring.repository;
import hello.hellospring.domain.Member;
import javax.persistence.EntityManager;
import java.util.List;
import java.util.Optional;
public class JpaMemberRepository implements MemberRepository {
   private final EntityManager em;
   public JpaMemberRepository(EntityManager em) {
     this.em = em;
 }
 public Member save(Member member) {
   em.persist(member);
   return member;
 }
 public Optional<Member> findById(Long id) {
   Member member = em.find(Member.class, id);
   return Optional.ofNullable(member);
 }
 public List<Member> findAll() {
   return em.createQuery("select m from Member m", Member.class)
   .getResultList();
 }
 public Optional<Member> findByName(String name) {
   List<Member> result = em.createQuery("select m from Member m where 
  m.name = :name", Member.class)
   .setParameter("name", name)
   .getResultList();
   return result.stream().findAny();
}
}
```

5. Transaction 추가
JPA를 쓰려면 (데이터를 저장/변경할 때) 항상 Transaction 필요
```java
import org.springframework.transaction.annotation.Transactional
@Transactional
public class MemberService { ...
```

6. SpringConfig에서 Spring 설정 변경

cf) MemberRepository를 JpaMemberRepository로 변경

cf) EntitiyManager 사용

```java
package hello.hellospring;
import hello.hellospring.repository.*;
import hello.hellospring.service.MemberService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import javax.persistence.EntityManager;
import javax.sql.DataSource;
@Configuration
public class SpringConfig {
     private final DataSource dataSource;
     private final EntityManager em;
     public SpringConfig(DataSource dataSource, EntityManager em) {
       this.dataSource = dataSource;
       this.em = em;
   }
   @Bean
   public MemberService memberService() {
     return new MemberService(memberRepository());
   }
   @Bean
   public MemberRepository memberRepository() {
    // return new MemoryMemberRepository();
    // return new JdbcMemberRepository(dataSource);
    // return new JdbcTemplateMemberRepository(dataSource);
     return new JpaMemberRepository(em);
   }
}
```





